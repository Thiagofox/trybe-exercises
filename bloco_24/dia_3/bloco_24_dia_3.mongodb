// Operador $all

// O operador $all seleciona todos os documentos em que o valor do campo √© um array que contenha todos os elementos especificados. Se compararmos aos operadores que j√° conhecemos, esse operador √© equivalente ao operador $and , pois far√° a compara√ß√£o de todos os valores especificados, por√©m, para arrays .
// Utiliza-se $all sempre que √© preciso passar mais de um valor de compara√ß√£o, e √© irrelevante para a verifica√ß√£o tanto a exist√™ncia de mais elementos no array quanto a ordem em que esses elementos est√£o.
// Entenda essa diferen√ßa com estas duas queries :

db.inventory.find({ tags: ["red", "blank"] });

db.inventory.find({ tags: { $all: ["red", "blank"] } });

// A primeira query retornar√° somente os documentos em que o array tags seja exatamente igual ao passado como par√¢metro no filtro, ou seja, contenha apenas esses dois elementos, na mesma ordem.
// J√° a segunda analisar√° o mesmo array , independentemente da exist√™ncia de outros valores ou a ordem em que os elementos estejam.
// Utilizar o $all poupa um pouco de c√≥digo. Veja um exemplo utilizando o $all :

db.inventory.find(
  { tags: { $all: [ "ssl", "security" ] } }
);

// E seu equivalente, utilizando o $and :

db.inventory.find(
  {
    $and: [
      { tags: "ssl" },
      { tags: "security" }
    ]
  }
);

// Operador $elemMatch

// O operador $elemMatch seleciona os documentos que cont√™m um campo do tipo array com pelo menos um elemento que satisfa√ßa todos os crit√©rios de sele√ß√£o especificados. Ou seja, com esse operador voc√™ pode especificar v√°rias queries para um mesmo array .

// Veja um exemplo considerando a cole√ß√£o scores com os seguintes documentos:
 
{ _id: 1, results: [82, 85, 88] },
{ _id: 2, results: [75, 88, 89] }

// A query abaixo seleciona somente os documentos em que o array results cont√©m ao menos um elemento que seja maior ou igual a 80 e menor que 85 :

db.scores.find(
  { results: { $elemMatch: { $gte: 80, $lt: 85 } } }
);

// Como resultado, apenas o documento com o _id igual a 1 ser√° retornado, j√° que o 82 satisfaz as duas verifica√ß√µes.

// Voc√™ pode utilizar o operador $elemMatch em arrays que contenham subdocumentos e especificar v√°rios campos desses subdocumentos como filtro. Veja os seguintes documentos na cole√ß√£o survey :

{
  _id: 1,
  results: [
    { product: "abc", score: 10 },
    { product: "xyz", score: 5 }
  ]
},
{
  _id: 2,
  results: [
    { product: "abc", score: 8 },
    { product: "xyz", score: 7 }
  ]
},
{
  _id: 3,
  results: [
    { product: "abc", score: 7 },
    { product: "xyz", score: 8 }
  ]
}

// A query abaixo selecionar√° apenas os documentos em que o array results contenha ao menos um elemento subdocumento com o campo product igual a xyz e o campo score maior ou igual a 8 :

db.survey.find(
  { results: { $elemMatch: { product: "xyz", score: { $gte: 8 } } } }
);

// Ser√° retornado apenas o documento com o _id igual a 3 .
// Voc√™ n√£o precisa utilizar o operador $elemMatch se estiver utilizando uma condi√ß√£o para apenas "um" campo do documento embedado . Veja:

db.survey.find(
  { results: { $elemMatch: { product: "xyz" } } }
);

// Como a opera√ß√£o acima s√≥ tem uma condi√ß√£o, o operador $elemMatch n√£o se faz necess√°rio e voc√™ pode utilizar a query abaixo:

db.survey.find(
  { "results.product": "xyz" }
);

// Operador $size

// O operador $size seleciona documentos em que um array contenha um n√∫mero de elementos especificado.
// Considere a cole√ß√£o products a seguir, contendo documentos em que o campo tags pode ser um array :

{ _id: 1, tags: ["red", "green"] },
{ _id: 2, tags: ["apple", "lime"] },
{ _id: 3, tags: "fruit" },
{ _id: 4, tags: ["orange", "lemon", "grapefruit"] }

// Ao executar a query abaixo, apenas os documentos com o _id igual 1 e 2 ser√£o retornados, pois seus campos tags s√£o arrays e cont√™m exatamente 2 elementos :

db.products.find(
  { tags: { $size: 2 } }
);

// √â importante saber que o operador $size aceita apenas valores n√∫mericos, n√£o sendo poss√≠vel, por exemplo, trazer arrays com comprimento maior do que 2 ($gt: 2). Se voc√™ precisar selecionar documentos com base em valores diferentes, a solu√ß√£o √© criar um campo que se incremente quando elementos forem adicionados ao array .


// Operador $where

// O operador $where pode ser utilizado para passar uma string contendo uma express√£o ou fun√ß√£o JavaScript . Esse operador √© muito flex√≠vel, mas requer que o banco de dados processe a express√£o ou fun√ß√£o passada para cada documento na cole√ß√£o. O documento √© referenciado na express√£o ou fun√ß√£o usando this ou obj .

// O operador $where n√£o ser√° explorado porque, na vers√£o 3.6 do MongoDB , um outro operador, $expr , que ser√° visto a seguir, passou a suportar express√µes de agrega√ß√£o. O operador $expr √© mais r√°pido do que o $where porque n√£o executa JavaScript . Recomendamo utilizar o $expr utiliz√°-lo sempre que poss√≠vel, mas trazemos o $where para mostrar que ele existe üòÑ!

// Para saber um pouco mais sobre o operador $where , clique aqui.


// Operador $expr

// O operador $expr permite que voc√™ utilize express√µes de agrega√ß√£o e construa queries que comparem campos no mesmo documento.
// Considere os documentos abaixo na cole√ß√£o monthlyBudget :

{ _id: 1, category: "food", budget: 400, spent: 450 },
{ _id: 2, category: "drinks", budget: 100, spent: 150 },
{ _id: 3, category: "clothes", budget: 100, spent: 50 },
{ _id: 4, category: "misc", budget: 500, spent: 300 },
{ _id: 5, category: "travel", budget: 200, spent: 650 }

// A query abaixo utiliza o operador $expr para buscar os documentos em que o valor de spent exceda o valor de budget :

db.monthlyBudget.find(
  {
    $expr: { $gt: [ "$spent", "$budget" ] }
  }
);

// Apenas os seguintes documentos ser√£o retornados:

{ "_id" : 1, "category" : "food", "budget" : 400, "spent" : 450 }
{ "_id" : 2, "category" : "drinks", "budget" : 100, "spent" : 150 }
{ "_id" : 5, "category" : "travel", "budget" : 200, "spent" : 650 }

// Note que, na query , nenhum valor foi especificado explicitamente. O que acontece √© que o operador $expr entende que deve comparar os valores dos dois campos. Por isso o $ √© utilizado, indicando que a string entre aspas referencia um campo.

// Mais √† frente no curso, voc√™ ver√° muito mais aplica√ß√µes para o operador $expr dentro do t√≥pico sobre Aggregation Framework , e ver√° que suas queries ficar√£o muito mais poderosas!


// Operador $regex

// O operador $regex fornece os "poderes" das express√µes regulares ( regular expressions ) para sele√ß√£o de strings . MongoDB utiliza express√µes regulares compat√≠veis com Perl ( PCRE ), vers√£o 8.42, e com suporte a UTF-8 .

// Um uso muito comum para o operador $regex √© fazer consultas como o LIKE do SQL . Considere os seguintes documentos na cole√ß√£o products :

{ _id: 100, sku: "abc123", description: "Single line description." },
{ _id: 101, sku: "abc789", description: "First line\nSecond line" },
{ _id: 102, sku: "xyz456", description: "Many spaces before     line" },
{ _id: 103, sku: "xyz789", description: "Multiple\nline description" }

// A query abaixo seleciona todos os documentos em que o campo sku "termine" com "789" :

db.products.find({ sku: { $regex: /789$/ } });

// O exemplo acima equivale ao comando LIKE do SQL :

SELECT * FROM products WHERE sku LIKE "%789";

// Voc√™ pode especificar op√ß√µes na regex. Por exemplo, voc√™ pode especificar a op√ß√£o case-insensitive , fazendo com que o MongoDB ignore letras mai√∫sculas ou min√∫sculas. Veja o exemplo abaixo, que retorna palavras "come√ßando" com ABC:

db.products.find({ sku: { $regex: /^ABC/i } });

// O caractere i ao lado da express√£o indica a op√ß√£o case-insensitive . Dessa forma, apenas os documentos que contenham ABC no campo sku ser√£o retornados, sem se importar se est√° em mai√∫sculo ou min√∫sculo:

{ "_id" : 100, "sku" : "abc123", "description" : "Single line description." }
{ "_id" : 101, "sku" : "abc789", "description" : "First line\nSecond line" }

// Basicamente, tudo o que voc√™ pode construir com express√µes regulares em outras linguagens de programa√ß√£o funcionar√° tamb√©m em suas queries no MongoDB.


// Operador $text

// O operador $text faz uma busca "textual" em um campo indexado por um text index. A express√£o para utilizar o $text tem a seguinte sintaxe:

{
  $text:
    {
      $search: <string>,
      $language: <string>,
      $caseSensitive: <boolean>,
      $diacriticSensitive: <boolean>
    }
}

// Em que:

// $search : Uma string com os termos que o MongoDB utilizar√° para fazer o parse e utilizar√° como filtro. Internamente, o MongoDB faz uma busca l√≥gica ( OR ) sobre os termos, a menos que seja especificado como uma frase inteira;

// $language : Opcional. Esse campo determina a lista de stop words que ser√° utilizada na tokeniza√ß√£o da busca. Veja a lista de idiomas suportados. Se voc√™ passar o valor none , a busca utilizar√° uma tokeniza√ß√£o simples sem utilizar nenhuma lista de stop words ;
// Stop word: Tamb√©m conhecido como palavra vazia , √© uma palavra que √© removida antes ou ap√≥s o processamento de um texto em linguagem natural.

// $caseSensitive : Opcional. Recebe um valor booleano para habilitar ou desabilitar buscas case sensitive . O valor default √© false , o que faz com que as buscas sejam case-insensitive . Veja mais informa√ß√µes sobre case-insensitive aqui;

// $diacriticSensitive : Opcional. Recebe um valor booleano para habilitar ou desabilitar busca diacritic sensitive . O valor default tamb√©m √© false .

// O operador $text , por padr√£o, n√£o retorna os resultados ordenados pelas pontua√ß√µes ( score ). Veja mais informa√ß√µes sobre ordena√ß√£o por scores aqui.
// O score √© atribu√≠do a cada documento que contenha o termo procurado no campo. Esse score representa a relev√¢ncia do documento para a busca textual aplicada. O score pode ser parte do m√©todo sort() ou parte de uma proje√ß√£o .

// Hora de ver alguns exemplos considerando a cole√ß√£o articles e um √≠ndice textual no campo subject .
// Primeiro, o comando para criar o √≠ndice do tipo text :

db.articles.createIndex({ subject: "text" });

// Tendo os seguintes documentos na cole√ß√£o articles :

{ _id: 1, subject: "coffee", author: "xyz", views: 50 },
{ _id: 2, subject: "Coffee Shopping", author: "efg", views: 5 },
{ _id: 3, subject: "Baking a cake", author: "abc", views: 90  },
{ _id: 4, subject: "baking", author: "xyz", views: 100 },
{ _id: 5, subject: "Caf√© Com Leite", author: "abc", views: 200 },
{ _id: 6, subject: "–°—ã—Ä–Ω–∏–∫–∏", author: "jkl", views: 80 },
{ _id: 7, subject: "coffee and cream", author: "efg", views: 10 },
{ _id: 8, subject: "Cafe com Leite", author: "xyz", views: 10 }

// Exemplo 1: Procurando um √∫nico termo
// A query abaixo utiliza os operadores $text e $search para buscar todos os documentos que contenham o termo coffee :

db.articles.find({ $text: { $search: "coffee" } });

// Exemplo 2: Procurando qualquer um dos termos especificados
// Voc√™ pode procurar por v√°rios termos passando uma string delimitada por espa√ßos . O operador $text far√° uma busca l√≥gica OR por cada um desses termos, retornando os documentos que contenham qualquer um deles.
// A query abaixo especifica tr√™s termos ( "bake coffee cake" ) para a string $search :

db.articles.find({ $text: { $search: "bake coffee cake" } });

// Exemplo 3: Procurando por uma frase
// Procurar por frases tamb√©m √© poss√≠vel. A query abaixo procura pela frase "coffee shop" :

db.articles.find({ $text: { $search: "\"coffee shop\"" } });

// Voc√™ ver√° mais exemplos e utiliza√ß√µes para o $text nos exerc√≠cios. Ver√° tamb√©m como esse operador se comporta muito bem com o Portugu√™s do Brasil !


// Operador $mod

// Saindo um pouco dos operadores textuais, existe o operador $mod , que seleciona todos os documentos em que o valor do campo dividido por um divisor seja igual ao valor especificado (ou seja, executa a opera√ß√£o matem√°tica m√≥dulo).

// Opera√ß√£o m√≥dulo: encontra o resto da divis√£o de um n√∫mero por outro.

// Considere os seguintes documentos na cole√ß√£o inventory :

{ _id: 1, item: "abc123", qty: 0 },
{ _id: 2, item: "xyz123", qty: 5 },
{ _id: 3, item: "ijk123", qty: 12 }

// A query a seguir seleciona todos os documentos da cole√ß√£o em que o valor do campo qty m√≥dulo 4 seja 0 :

db.inventory.find({ qty: { $mod: [4, 0] } });

// Ent√£o, apenas os seguintes documentos ser√£o retornados:

{ "_id" : 1, "item" : "abc123", "qty" : 0 }
{ "_id" : 3, "item" : "ijk123", "qty" : 12 }